//
// Copyright 2019 Intel Corporation.
//
// This software and the related documents are Intel copyrighted materials,
// and your use of them is governed by the express license under which they
// were provided to you (End User License Agreement for the Intel(R) Software
// Development Products (Version May 2017)). Unless the License provides
// otherwise, you may not use, modify, copy, publish, distribute, disclose or
// transmit this software or the related documents without Intel's prior
// written permission.
//
// This software and the related documents are provided as is, with no
// express or implied warranties, other than those that are expressly
// stated in the License.
//


#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <tuple>
#include <list>

#include <inference_engine.hpp>

#include <ie_icnn_network_stats.hpp>
#include <cnn_network_int8_normalizer.hpp>
#include <ie_util_internal.hpp>
#include <ie_compound_blob.h>

#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

using namespace InferenceEngine;

Blob::Ptr yoloLayer_yolov2tiny(const Blob::Ptr &lastBlob, int inputHeight, int inputWidth) {
    const TensorDesc quantTensor = lastBlob->getTensorDesc();
    const TensorDesc outTensor = TensorDesc(InferenceEngine::Precision::FP32,
        {1, 1, 13*13*20*5, 7},
        lastBlob->getTensorDesc().getLayout());
    Blob::Ptr outputBlob = make_shared_blob<float>(outTensor);
    outputBlob->allocate();

    const float *inputRawData = lastBlob->cbuffer().as<const float *>();
    float *outputRawData = outputBlob->buffer().as<PrecisionTrait<Precision::FP32>::value_type *>();

    int shape[]={13, 13, 5, 25};
    int strides[]={13*128, 128, 25, 1};
    postprocess::yolov2(inputRawData, shape, strides,
        0.4f, 0.45f, 20, 416, 416, outputRawData);

    return outputBlob;
}

/**
* @brief The entry point the Inference Engine sample application
* @file detection_sample/main.cpp
* @example detection_sample/main.cpp
*/
int main(int argc, char *argv[]) {
    try {
        slog::info << "InferenceEngine: " << GetInferenceEngineVersion() << slog::endl;

        slog::info << "Creating Inference Engine" << slog::endl;
        Core ie;

        // --------------------------- 2. Read blob Generated by MCM Compiler ----------------------------------
        std::string binFileName = FLAGS_m;
        slog::info << "Loading blob:\t" << binFileName << slog::endl;

        ExecutableNetwork importedNetwork = ie.ImportNetwork(binFileName, "KMB", {});
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 3. Configure input & output ---------------------------------------------
        ConstInputsDataMap inputInfo = importedNetwork.GetInputsInfo();

        for (auto & item : inputInfo) {
            InputInfo* mutableItem = const_cast<InputInfo*>(item.second.get());
            setPreprocAlgorithm(mutableItem, PT_NV12);
            setPreprocAlgorithm(mutableItem, PT_RESIZE);
        }
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 4. Create infer request -------------------------------------------------
        InferenceEngine::InferRequest inferRequest = importedNetwork.CreateInferRequest();
        slog::info << "CreateInferRequest completed successfully" << slog::endl;
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 5. Prepare input --------------------------------------------------------
        /** Iterate over all the input blobs **/
        std::string firstInputName = inputInfo.begin()->first;
        /** Creating input blob **/
        Blob::Ptr inputBlob = inferRequest.GetBlob(firstInputName.c_str());
        if (!inputBlob) {
            throw std::logic_error("Cannot get input blob from inferRequest");
        }

        for (auto & item : inputInfo) {
            std::string inputName = item.first;
            InferenceEngine::TensorDesc inputTensor = item.second->getTensorDesc();
            setPreprocForInputBlob(inputName, inputTensor, imageFileName, inferRequest, kmbAllocator);
        }

        inferRequest.Infer();
        slog::info << "inferRequest completed successfully" << slog::endl;
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 6. Process output -------------------------------------------------------
        slog::info << "Processing output blobs" << slog::endl;

        ConstOutputsDataMap outputInfo = importedNetwork.GetOutputsInfo();
        if (outputInfo.size() != 1) throw std::logic_error("Sample supports topologies only with 1 output");

        std::string firstOutputName = outputInfo.begin()->first;

        Blob::Ptr outputBlob = inferRequest.GetBlob(firstOutputName.c_str());
        if (!outputBlob) {
            throw std::logic_error("Cannot get output blob from inferRequest");
        }

        // de-Quantization
        uint8_t zeroPoint = static_cast<uint8_t>(FLAGS_z);
        float scale = static_cast<float>(FLAGS_s);

        // Real data layer
        Blob::Ptr dequantOut = deQuantize(outputBlob, scale, zeroPoint);

        // Region YOLO layer
        int inputHeight = inputBlob->getTensorDesc().getDims()[2];
        int inputWidth = inputBlob->getTensorDesc().getDims()[3];
        Blob::Ptr detectResult = yoloLayer_yolov2tiny(dequantOut, inputHeight, inputWidth);

        // Print result.
        size_t N = detectResult->getTensorDesc().getDims()[2];
        if (detectResult->getTensorDesc().getDims()[3] != 7) {
            throw std::logic_error("Output item should have 7 as a last dimension");
        }
        const float *rawData = detectResult->cbuffer().as<const float *>();
        // imageid,labelid,confidence,x0,y0,x1,y1
        for (size_t i = 0; i < N; i++) {
            if (rawData[i*7 + 2] > 0.001) {
                slog::info << "confidence = " << rawData[i*7 + 2] << slog::endl;
                slog::info << "x0,y0,x1,y1 = " << rawData[i*7 + 3] << ", "
                    << rawData[i*7 + 4] << ", "
                    << rawData[i*7 + 5] << ", "
                    << rawData[i*7 + 6] << slog::endl;
            }
        }

        FILE* outFile  = fopen("/output.dat", "wb");
        fwrite(outputBlob->buffer(), sizeof(u_char), outputBlob->byteSize(), outFile);
        fclose(outFile);
    }
    catch (const std::exception& error) {
        slog::err << "" << error.what() << slog::endl;
        return 1;
    }
    catch (...) {
        slog::err << "Unknown/internal exception happened." << slog::endl;
        return 1;
    }

    slog::info << "Execution successful" << slog::endl;
    return 0;
}
